import 'dart:math';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import '../models/app_models.dart';
import 'database_service.dart';

class TerritoryLogicService {
  final DatabaseService _db = DatabaseService();

  /// Converts a raw GPS route (list of LatLng) into a simplified Territory Polygon.
  /// MVP Algorithm: Create a bounding box based on the min/max lat and long of the run.
  Future<Territory?> generateTerritoryFromRun({
    required String userId,
    required String userName,
    required List<LatLng> route,
    required double distanceKm,
  }) async {
    // Basic protection: don't claim territories for tiny runs.
    if (route.length < 5 || distanceKm < 0.1) {
      return null;
    }

    // Step 1: Find Min and Max Lat/Long to form a bounding box
    double minLat = route.first.latitude;
    double maxLat = route.first.latitude;
    double minLng = route.first.longitude;
    double maxLng = route.first.longitude;

    for (var point in route) {
      if (point.latitude < minLat) minLat = point.latitude;
      if (point.latitude > maxLat) maxLat = point.latitude;
      if (point.longitude < minLng) minLng = point.longitude;
      if (point.longitude > maxLng) maxLng = point.longitude;
    }

    // The corners of our new bounding box Territory
    List<LatLng> polygonPoints = [
      LatLng(maxLat, minLng), // Top Left
      LatLng(maxLat, maxLng), // Top Right
      LatLng(minLat, maxLng), // Bottom Right
      LatLng(minLat, minLng), // Bottom Left
    ];

    // Step 2: Calculate Area of this new bounding box (roughly in square kilometers)
    // using the Haversine distance between top-left/top-right and top-left/bottom-left.
    double widthKm = _haversineDistance(maxLat, minLng, maxLat, maxLng);
    double heightKm = _haversineDistance(maxLat, minLng, minLat, minLng);
    double areaSqKm = widthKm * heightKm;

    // Optional: Inflate the box slightly to make it look better on the map
    areaSqKm = (areaSqKm < 0.01) ? 0.01 : areaSqKm;

    // Step 3: Check for overlaps with existing territories
    // (MVP: Query all territories and check bounding box collision)
    // NOTE: In production, we would use GeoQueries to limit the search space.
    final existingTerritories = await _db.streamGlobalTerritories().first;

    Territory? overtakenTerritory;

    for (var existing in existingTerritories) {
      if (_doesOverlap(polygonPoints, existing.polygonPoints)) {
        // Simple overtake rule: If the new run is longer than the old run's area score, overtake it.
        // Or for MVP, simply the last active runner claims the intersecting zone.
        overtakenTerritory = existing;
        break;
      }
    }

    // Step 4: Write to Database
    if (overtakenTerritory != null) {
      await _db.overWriteTerritoryOwner(
          overtakenTerritory.id, overtakenTerritory.ownerId, userId, userName);

      // We return the old territory but with updated owner details
      return Territory(
        id: overtakenTerritory.id,
        ownerId: userId,
        ownerName: userName,
        areaSqKm: overtakenTerritory.areaSqKm,
        polygonPoints: overtakenTerritory.polygonPoints,
        createdAt: DateTime.now(),
      );
    } else {
      // Create a brand new territory
      final newTerritory = Territory(
        id: '', // Set by DatabaseService
        ownerId: userId,
        ownerName: userName,
        areaSqKm: areaSqKm,
        polygonPoints: polygonPoints,
        createdAt: DateTime.now(),
      );

      await _db.claimTerritory(newTerritory);
      return newTerritory;
    }
  }

  // Helper: Haversine distance in km
  double _haversineDistance(
      double lat1, double lon1, double lat2, double lon2) {
    const double r = 6371; // Earth radius in km
    final double dLat = _toRadians(lat2 - lat1);
    final double dLon = _toRadians(lon2 - lon1);
    final double a = sin(dLat / 2) * sin(dLat / 2) +
        cos(_toRadians(lat1)) *
            cos(_toRadians(lat2)) *
            sin(dLon / 2) *
            sin(dLon / 2);
    final double c = 2 * atan2(sqrt(a), sqrt(1 - a));
    return r * c;
  }

  double _toRadians(double degree) {
    return degree * pi / 180;
  }

  // MVP Overlap check (AABB Collision basically)
  bool _doesOverlap(List<LatLng> polyA, List<LatLng> polyB) {
    // If we assume both are axis-aligned bounding boxes from our generator:
    if (polyA.isEmpty || polyB.isEmpty) return false;

    double minLatA = polyA[3].latitude; // Bottom Left
    double maxLatA = polyA[0].latitude; // Top Left
    double minLngA = polyA[3].longitude;
    double maxLngA = polyA[1].longitude; // Top Right

    // Find bounds for B (in case B wasn't generated by our simple box)
    double minLatB = polyB.first.latitude;
    double maxLatB = polyB.first.latitude;
    double minLngB = polyB.first.longitude;
    double maxLngB = polyB.first.longitude;

    for (var point in polyB) {
      if (point.latitude < minLatB) minLatB = point.latitude;
      if (point.latitude > maxLatB) maxLatB = point.latitude;
      if (point.longitude < minLngB) minLngB = point.longitude;
      if (point.longitude > maxLngB) maxLngB = point.longitude;
    }

    // Check for overlap
    bool overlapX = minLngA <= maxLngB && maxLngA >= minLngB;
    bool overlapY = minLatA <= maxLatB && maxLatA >= minLatB;

    return overlapX && overlapY;
  }
}
